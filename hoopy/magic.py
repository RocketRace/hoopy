"""
This module exposes the magic dunder functions used in the implementation of the library.

These are generated by the `transform` module as a result of desugaring the "functional" syntactic sugar.

Examples of possible desugarings include:
```
# from `from mod import ($)`
__import_operator__(__name__, "$", "module")

# from `a = x $ y`
a = __operator__(__name__, "$")(x, y)

# from `b = ($)`
b = __operator__(__name__, "$")

# from `def ($!)(x, y): pass`
@__define_operator__("$!", flipped=False)
def __operator_foo_2421(x, y):
    pass

# from `@dataclass def (>:): l: int; r: int`
@__define_operator__(">:", flipped=False)
class __operator_foo_3e3a:
    l: int
    r: int
```
"""
from __future__ import annotations
import importlib
import sys

from typing import Any, Callable

from .infix import infix
from .utils import T, U, V, Decorator, FunctionContext, context
from .runtime import (
    BUILTIN_OPERATORS,
    InfixOperator,
    LeftInfixOperable,
    PartialFunction,
    RightInfixOperable,
    bind_op_to,
)

# The transformer inserts `from hoopy.magic import *` to transformed programs
__all__ = (
    "__operator__",
    "__import_operator__",
    "__partial_apply__",
    "__define_operator__",
)


def __operator__(
    module: str, op: str, verbatim: bool = False
) -> Callable[[Any, Any], Any]:
    """Derived from `($)` or `x $ y`"""
    # verbatim operators are always custom, even if they are the same operator as custom ones
    if op in BUILTIN_OPERATORS and not verbatim:
        return BUILTIN_OPERATORS[op]

    def get(left: object, right: object) -> object:
        # The `Any` annotation is needed due to type checker limitations.
        lt: Any = type(left)
        if isinstance(lt, LeftInfixOperable):
            operator = lt.__infix_operators__.get(op)
            if operator is not None:
                return operator(left, right)

        rt: Any = type(right)
        if isinstance(rt, RightInfixOperable):
            operator = rt.__infix_operators_flipped__.get(op)
            if operator is not None:
                return operator(left, right)

        mod: Any = sys.modules[module]
        if isinstance(mod, LeftInfixOperable):
            operator = mod.__infix_operators__.get(op)
            if operator is not None:
                return operator(left, right)

        raise TypeError(
            f"Unsupported operand type(s) for {op}: '{type(left).__name__}' and '{type(right).__name__}'"
        )

    return get


def __import_operator__(
    target_module: str, source_module: str, level: int, op: str
) -> None:
    """Derived from `from mod import ($)`"""
    src = importlib.import_module(source_module, level * "." if level else None)
    operator = src.__infix_operators__[op]
    bind_op_to(sys.modules[target_module], operator)


def __partial_apply__(function: Any, argument: Any) -> Any:
    """Derived from `f x`"""
    if isinstance(function, PartialFunction):
        return function(argument)
    else:
        return PartialFunction(function)(argument)


def __define_operator__(
    op: str, *, flipped: bool, verbatim: bool
) -> Decorator[[T, U], V, InfixOperator[T, U, V]]:
    """
    Derived from `def ($)(x, y): ...` or `class ($): def __new__(cls, left, right): ...`
    """

    def inner(fn: Callable[[T, U], V], /) -> InfixOperator[T, U, V]:
        return infix(
            op, flipped and context(fn) == FunctionContext.Class, verbatim=verbatim
        )(fn)

    return inner
